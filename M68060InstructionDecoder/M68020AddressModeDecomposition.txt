
68020+ address mode decomposition into simpler ops
==================================================

Move with (bd,An,Xi*SF) instruction source operand takes 1 extra cycle to compute

	MOVE.L	($11111111,A0,D0.L*4),D1
		LEA	($11111111,A0,D0.L*4),AGU_TEMP
		MOVE.L (AGU_TEMP),D1

Move with memory indirect source operand - regardless of which elements are present and which are suppressed - take 3 extra cycles to compute
		
	MOVE.L	([$11111111,A0,D0.L*4],$22222222),D1
		LOAD.L	[$11111111,A0,D0.L*4],AGU_TEMP
		LEA	(AGU_TEMP,$22222222),AGU_TEMP
		MOVE.L	(AGU_TEMP),D1

Move with double memory operands are split up into load & store:

	MOVE.L	(A0),(A1)
		MOVE.L	(A0),MOVE_TEMP
		MOVE.L	MOVE_TEMP,(A1)

MOVE with double 68020+ addressing modes use double AGU_TEMP operands
		
	MOVE.L	([$11111111,A0,D0.L*4],$22222222),([$33333333,A1,D2.L*8],$44444444)
		LOAD.L	[$11111111,A0,D0.L*4],AGU_TEMP
		LEA.L	(AGU_TEMP,$22222222),AGU_TEMP
		MOVE.L	(AGU_TEMP),MOVE_TEMP
		LOAD.L	[$33333333,A1,D2.L*8],AGU_TEMP
		LEA.L	(AGU_TEMP,$44444444),AGU_TEMP
		MOVE.L	MOVE_TEMP,(AGU_TEMP)
	
Add operations with memory indirect operands use the AGU_TEMP register with the same usage pattern as MOVE
	
	ADD.L	([$11111111,A0,D0.L*4],$22222222),D1
		LOAD.L	[$11111111,A0,D0.L*4],AGU_TEMP
		LEA	(AGU_TEMP,$22222222),AGU_TEMP
		ADD.L	(AGU_TEMP),D1

	ADD.W	([$11111111,A0,D0.L*4],$22222222),D1
		LOAD.L	[$11111111,A0,D0.L*4],AGU_TEMP
		LEA	(AGU_TEMP,$22222222),AGU_TEMP
		ADD.W	(AGU_TEMP),D1

	ADD.L	D1,([$11111111,A0,D0.L*4],$22222222)
		LOAD.L	[$11111111,A0,D0.L*4],AGU_TEMP
		LEA	(AGU_TEMP,$22222222),AGU_TEMP
		ADD.L	D1,(AGU_TEMP)

	ADD.W	D1,([$11111111,A0,D0.L*4],$22222222)
		LOAD.L	[$11111111,A0,D0.L*4],AGU_TEMP
		LEA	(AGU_TEMP,$22222222),AGU_TEMP
		ADD.L	D1,(AGU_TEMP)

